
### FIGURE OUT IF THESE SHOULD ALL BE ON BY DEFAULT ###

startup_volumes() {
# Setup those funky hardware/software raid things
if [ -n "${DMRAID}" ]
then
	if [ -e '/sbin/dmraid' ]
	then
		good_msg "Activating Device-Mapper RAID(s)"
		/sbin/dmraid -ay ${DMRAID_OPTS}
	fi
fi

# MD devices ( software raid )
if [ -n "${MDADM}" ]
then
	if [ -e '/sbin/mdadm' ]
	then
		good_msg "Activating boot md array"
		if [ -n "$rootuuid" ]
		then 
			arg=--uuid=$rootuuid
		elif [ -n "$mdminor" ]
		then 
			arg=--super-minor=$mdminor
		else 
			arg=--super-minor=0
		fi
		/sbin/mdadm -Acpartitions $arg --auto=part /dev/mda
	fi
fi

# lvm
if [ -n "${LVM2}" ]
then
	if [ -e '/sbin/lvm.static' ]
	then
		good_msg "Scanning for Volume Groups"
		/sbin/lvm.static vgscan --ignorelockingfailure --mknodes 2>/dev/null
		good_msg "Activating Volume Groups"
		/sbin/lvm.static vgchange -ay --ignorelockingfailure 2>/dev/null

		if has "evms2" "$CMDLINE"
		then
			bad_msg "Disabling EVMS Support because LVM2 started"
			bad_msg "Do not add dolvm2 to the cmdline if this is not what you want"
			bad_msg "LVM2 and EVMS do not work well together"
			DISABLE_EVMS2=true
		fi
	fi
fi

if [ -n "${LVM2}" ]
then
	if [ -e '/sbin/evms_activate' -a "${DISABLE_EVMS2}" != 'true' ]
	then
		good_msg "Activating EVMS"
		evms_activate
	fi
fi
}


findcdmount() {
	if [ "$#" -gt "0" ]
	then
		[ ! -e "${CD_MOUNT}" ] && mkdir -p "${CD_MOUNT}"

		if [ "${REAL_ROOT}" == "/dev/nfs" ]
		then
			good_msg "Attempting to mount NFS CD image on ${NFSROOT}"
			mount ${NFSROOT} ${CD_MOUNT}
			if [ "$?" = '0' ]; then
				check_image ${CD_MOUNT}
			else
				bad_msg "NFS Mounting failed."
				REAL_ROOT=''
			fi
		else	
			for x in $*
			do
				if [ -b "${x}" ]
				then
					umount "${NEWROOT}/${LOOP_MNTPOINT}"  > /dev/null 2>&1
					umount "${CD_MOUNT}"  > /dev/null 2>&1
				
					good_msg "Attempting to mount CD:- ${x}"
					mount -r ${x} ${CD_MOUNT} > /dev/null 2>&1
					if [ "$?" = '0' ]
					then
						# check for a livecd
						check_image ${CD_MOUNT}
						break
						if [ -n "${IMAGE_ROOT}" ]
						then
							break
						else
							umount ${CD_MOUNT} > /dev/null 2>&1
						fi
					else
						umount ${CD_MOUNT} > /dev/null 2>&1
					fi
				fi	
			done
		fi
	fi
}


check_image(){

	if  [ "${LOOP}" = '' ]
	then
		# Find the loop file at gentoo's default locations
		if [ -e "${1}/${SUBDIR}/livecd.loop" ]; then
			LOOP='/livecd.loop'
			LOOPTYPE='normal'
		elif [ -e "${1}/${SUBDIR}/zisofs" ]; then
			LOOP='/zisofs'
			LOOPTYPE='zisofs'
		elif [ -e "${1}/${SUBDIR}/livecd.squashfs" ]; then
			LOOP='/livecd.squashfs'
			LOOPTYPE='squashfs'
		else
			LOOPTYPE='noloop'
		fi
	fi

	if [ "${LOOPTYPE}" = '' ]
	then
		setup_image_directory "${1}/${SUBDIR}/${LOOP}" 
		setup_image_loop "${1}/${SUBDIR}/${LOOP}" "${NEWROOT}/${LOOP_MNTPOINT}"
		setup_image_sgimips "${1}/${SUBDIR}/${LOOP}" "${NEWROOT}/${LOOP_MNTPOINT}"
	elif [ "${LOOPTYPE}" = 'zisofs' ]; then
		setup_image_directory "${1}/${SUBDIR}/${LOOP}"
	elif [ "${LOOPTYPE}" = 'noloop' ]; then
		setup_image_directory "${1}/${SUBDIR}/${LOOP}"
	elif [ "${LOOPTYPE}" = 'normal' ]; then
		setup_image_loop "${1}/${SUBDIR}/${LOOP}" "${NEWROOT}/${LOOP_MNTPOINT}"
	elif [ "${LOOPTYPE}" = 'squashfs' ]; then
		setup_image_loop "${1}/${SUBDIR}/${LOOP}" "${NEWROOT}/${LOOP_MNTPOINT}"
	elif [ "${LOOPTYPE}" = 'sgimips' ]; then
		setup_image_sgimips "${1}/${SUBDIR}/${LOOP}" "${NEWROOT}/${LOOP_MNTPOINT}"
	fi	
		


	
}


set_image_root() {
	# Add a check for init
	if [ -n "${image_key}" ]
	then
		if [ -e "${1}/${image_key}" ]
		then
			IMAGE_ROOT="${1}"
		else
			echo "The key was not found"
		fi
	else
		IMAGE_ROOT="${1}"
	fi
}

setup_image_directory() {
	if [ -z "${IMAGE_ROOT}" ]
	then
		# Add a check for init
		if [ -d ${1} ]
		then
			set_image_root ${1}
		fi
	fi
}

setup_image_loop() {
	if [ -z "${IMAGE_ROOT}" ]
	then
		[ ! -e ${2} ] && mkdir -p ${2}
		for i in "-t ext2 -o loop,ro" "-t squashfs -o loop,ro"
		do
			mount $i $1 $2 > /dev/null 2>&1
			if [ "$?" -eq '0' ]
			then
				set_image_root ${2}
				[ -n "${IMAGE_ROOT}" ] && got_good_root=1 && break
			fi
		done
	fi
}

setup_image_sgimips() {
	if [ -z "${IMAGE_ROOT}" ]
	then
		echo ' ' | \
			losetup -o $(/bin/getdvhoff ${NEWROOT}${REAL_ROOT} 0) \
			${NEWROOT}${CDROOT_DEV} \
			${NEWROOT}${REAL_ROOT}
			if [ "$?" -eq '0' ]
			then
				mount -t ext2 -o ro ${NEWROOT}${CDROOT_DEV} $2 > /dev/null 2>&1
				if [ "$?" -eq '0' ]
				then
					set_image_root ${2}
				fi
			fi
	fi
}


setup_networking() {
	if [ "${IP}" != '' ]; then
		#ip=<client-ip>:<server-ip>:<gw-ip>:<netmask>:<hostname>:<device>:<autoconf>
		if [ "${IP}" != 'DHCP' ]
		then
			CLIENT_IP=$(echo ${IP}|cut -d : -f 1)
			SERVER_IP=$(echo ${IP}|cut -d : -f 2)
			GW_IP=$(echo ${IP}|cut -d : -f 3)
			NETMASK=$(echo ${IP}|cut -d : -f 4)
			HOSTNAME=$(echo ${IP}|cut -d : -f 5)
			ETH_DEVICE=$(echo ${IP}|cut -d : -f 6)

			[ -n "${ETH_DEVICE}" ] && IFCONFIG_ETH_DEVICE="${ETH_DEVICE}" ||IFCONFIG_ETH_DEVICE="eth0"
			# busybox ifconfig crashes if we dont bring up the device first	
			ifconfig ${IFCONFIG_ETH_DEVICE} up > /dev/null 2>&1
			[ -n "${NETMASK}" ] && IFCONFIG_ARGS="${IFCONFIG_ARGS} ${NETMASK}"
			
			# busybox ifconfig crashes if we dont bring up the device first	
			ifconfig ${IFCONFIG_ETH_DEVICE} ${CLIENT_IP} ${IFCONFIG_ARGS} up > /dev/null 2>&1

			if [ -n "${GW_IP}" ]
			then
				route add default gw ${GW_IP} > /dev/null 2>&1
			fi
		else
			if [ -e /sbin/udhcp ]
			then
				udhcp
			fi
		fi
		ifconfig lo up > /dev/null 2>&1
		if [ -e /sbin/portmap ]
		then
			portmap &
		fi
	fi
	
	if [ "${NAMESERVER}" != '' ]
	then
		echo "nameserver ${NAMESERVER}" > /etc/resolv.conf
	fi

}


findnfsmount() {
	if [ "${CLIENT_IP}" != '' -a "${REAL_ROOT}" == '/dev/nfs' ]; then
		if [ "${NFSROOT}" = '' ]; then
			# Obtain NFSIP
			OPTIONS=`busybox dmesg | grep rootserver | sed -e "s/,/ /g"`
			for OPTION in $OPTIONS
			do
				if [ `echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 1` = 'rootserver' ]; then
					NFSIP=`echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 2`;
				fi
			done

			# Obtain NFSPATH
			OPTIONS=`busybox dmesg | grep rootpath | sed -e "s/,/ /g"`
			for OPTION in $OPTIONS
			do
				if [ `echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 1` = 'rootpath' ]; then
					NFSPATH=`echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 2`;
				fi
			done

			# Setup NFSROOT
			if [ "${NFSIP}" != '' ] && [ "$NFSPATH" != '' ]
			then
				NFSROOT="${NFSIP}:${NFSPATH}"
			else
				bad_msg "The DHCP Server did not send a valid root-path."
				bad_msg "Please check your DHCP setup, or provide a nfsroot=<...> parameter."
			fi
		fi
	fi
}

cache_cd_contents() {
	good_msg "Caching the cd contents"
	cp -a ${IMAGE_ROOT} ${NEWROOT} 2>/dev/null
	if [ $? -ne 0 ]
	then
		bad_msg "Failed to cache the loop file! Lack of space?"
		cd ${NEWROOT}
		for i in `ls .`
		do
			if [ $i != 'mnt' -a $i != 'dev' ]
			then
				rm -r $i
			fi
		done

		bad_msg "Clearing cache... booting cdrom without cache...."
		setup_links
	else
		umount ${IMAGE_ROOT}
		umount ${CD_MOUNT}
	fi
}

setup_links() {
	good_msg "Copying read-write image contents to ${NEWROOT}"
	cd ${IMAGE_ROOT}
	cp -a ${ROOT_TREES} ${NEWROOT}

	cd ${NEWROOT}
	# Now we do the links.
	for x in ${ROOT_LINKS}
   	do
		if [ -L "${IMAGE_ROOT}/${x}" ]
		then
			#ln -s "`readlink ${IMAGE_ROOT}/${x}`" "${x}" 2>/dev/null
			ln -s "${LOOP_MNTPOINT}/${x}" "${x}" 2>/dev/null
		else
			# List all subdirectories of x
			for directory in `find "${IMAGE_ROOT}/${x}" -type d 2>/dev/null`
			do
				## Strip the prefix of the FS_LOCATION
				directory=${directory#${IMAGE_ROOT}/}

				## Skip this directory if we already linked a parent directory
				if [ "${current_parent}" != '' ]; then
					var=`echo "${directory}" | grep "^${current_parent}"`
					if [ "${var}" != '' ]; then
						continue
					fi
				fi

				## Test if the directory exists already
				if [ -e "/${NEWROOT}/${directory}" ]
				then
					# It does exist, link all the individual files
					for file in `ls /${IMAGE_ROOT}/${directory}`
					do
						if [ ! -d "/${IMAGE_ROOT}/${directory}/${file}" ] && \
							[ ! -e "${NEWROOT}/${directory}/${file}" ]; then
							ln -s "${LOOP_MNTPOINT}/${directory}/${file}" "${directory}/${file}" 2> /dev/null
						fi
					done
				else
					# It does not exist, make a link to the livecd
					ln -s "${LOOP_MNTPOINT}/${directory}" "${directory}" 2>/dev/null
					current_parent=${directory}
				fi
			done
		fi
	done
        
		mkdir initrd proc tmp sys 2>/dev/null
        chmod 1777 tmp
		good_msg "Copying read-write Finished"
}

sdelay() {
	# Sleep a specific number of seconds if SDELAY is set otherwise only 1 second
	if [ -n "${SDELAY}" ]; then
		sleep ${SDELAY}
	else
		sleep 1
	fi
} 

splash() {
	return 0
}


has() {
    local test=${1} item
    shift
	for item in $@; do
       [[ ${item} == ${test} ]] && return 0
    done
    return 1
}

# Kernel message verbosity
quiet_kmsg() {
	# if QUIET is set make the kernel less chatty
	[ -n "$QUIET" ] && echo '0' > /proc/sys/kernel/printk
}

verbose_kmsg() {
	# if QUIET is set make the kernel less chatty
	[ -n "$QUIET" ] && echo '6' > /proc/sys/kernel/printk
}

# Message options
good_msg() {
	msg_string=$1
	msg_string="${msg_string:-...}"
	echo -e "${GOOD}>>${NORMAL}${BOLD} ${msg_string} ${NORMAL}"
}

bad_msg() {
	msg_string=$1
	msg_string="${msg_string:-...}"
	echo -e "${BAD}!!${NORMAL}${BOLD} ${msg_string} ${NORMAL}"
}

warn_msg() {
	msg_string=$1
	msg_string="${msg_string:-...}"
	echo -e "${WARN}**${NORMAL}${BOLD} ${msg_string} ${NORMAL}"
}

# Shell functions
rundebugshell(){
	if [ -n "$DEBUG" ]; then
	good_msg 'Starting debug shell as requested by "debug" option.'
	good_msg 'Type "exit" to continue with normal bootup.'
	cd /
	[ -x /bin/sh ] && /bin/sh || /bin/ash
	fi
}

run_shell() {
	cd /
	/bin/ash
}

