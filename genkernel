#!/bin/bash
# Genkernel v4

PATH='/bin:/usr/bin:/sbin:/usr/sbin'
GK_V='4.0.0_alpha1'

# Needs to be here in case sourcing a file fails. 
die() {
  echo "${BAD}Error${NORMAL}: $1"
  exit 1
}

source genkernel.conf || die "Failed to source genkernel.conf"
source ${CORE_DIR}/gen_coreFunctions.sh || die "Failed to source gen_coreFunctions.sh"
source ${CORE_DIR}/gen_dependencyEngine.sh || die "Failed to source gen_dependencyEngine.sh"
source ${CORE_DIR}/gen_processPackages.sh || die "Failed to source gen_processPackages.sha"
source ${CORE_DIR}/gen_processKernelTree.sh || die "Failed to source gen_processKernelTree.sh"
source ${CORE_DIR}/gen_cmdline.sh || die "Failed to source gen_cmdline.sh"
source ${CORE_DIR}/gen_initialize.sh || die "Failed to source gen_initialize.sh"
source ${CORE_DIR}/gen_initramfs.sh || die "Failed to source gen_initramfs.sh"

trap trap_cleanup SIGHUP SIGQUIT SIGINT SIGTERM SIGKILL

# Parse all command line options...
Options=$@
	
# Internal flag to check if config parsing succeeded
__INTERNAL__CONFIG_PARSING_FAILED=false

while [ $# -gt 0 ]
do
	Option=$1; shift
	parse_cmdline $Option
done

# Failed to parse the cmdline properly, die so we can investigate...
logicTrue ${__INTERNAL__CONFIG_PARSING_FAILED} && die 'Fatal error processing arguments; exiting...'

set_color
logicTrue $(config_get_key help) && show_help && echo && exit 0 # --help

if [ -n "$(config_get_key profile)" ]
then
	for i in "$(config_get_key profile)"
	do
		config_profile_read $i
	done
fi	

# Set DEBUGFILE if log-override is defined
[ -n "$(config_get_key log-override)" ] && DEBUGFILE="$(config_get_key log-override)"

# Set TEMP if tempdir is defined
[ -n "$(config_get_key tempdir)" ] && TEMP="$(config_get_key tempdir)"

[ -n "$(config_get_key profile-dump)" ] && config_profile_dump

# Check if any modules to execute were specified
if [ "${__INTERNAL__CONFIG_PARSING_DEPTREE}" = '' ]
then
	echo 'Fatal error: no modules to execute specified...'
	show_usage
	exit 1
fi

clear_log

genkernel_print_header
genkernel_determine_arch

CACHE_DIR="$(arch_replace ${CACHE_DIR})"
CONFIG_DIR="$(arch_replace ${CONFIG_DIR})"
[ -e "${CACHE_DIR}" ] || mkdir -p "${CACHE_DIR}"
[ -e "${CONFIG_DIR}" ] || mkdir -p "${CONFIG_DIR}"

genkernel_lookup_packages
genkernel_lookup_kernel

# Process depends
print_info 1 '>> Processing dependency tree...'
require "${__INTERNAL__CONFIG_PARSING_DEPTREE}"

# Repeat the process since we now (might) have package-based callbacks
# Sourcing the dependency engine an additional engine makes the scrubber code erase
# previously calculated deptrees, which is what we want here.
source ${CORE_DIR}/gen_dependencyEngine.sh || die "Failed to resource gen_dependencyEngine.sh"

# Reprocess
genkernel_lookup_packages
genkernel_lookup_kernel silent
require "${__INTERNAL__CONFIG_PARSING_DEPTREE}"
require_DebugStack
# Generate TEMP dir
if [ ! -d "${TEMP}" ]
then
	mkdir -p "${TEMP}" || die "Failed to create temporary directory!"
fi

#Create the cache dir if it doesnt exist
setup_cache_dir

genkernel::()
{
	print_info 1 '>> Dependencies processed successfully!'
}

# If we have a callback set require the callback module
[ -n "$(config_get_key callback)" ] && require callback

for i in $(buildDepTreeSolution)
do
	print_info 1 ">> Executing module $i..."
	$i:: || die "$i module call failed!"
done

# End of execution for now
exit 255

# Read arch-specific config
source ${ARCH_CONFIG} || die "Could not read ${ARCH_CONFIG}"
source ${GK_SHARE}/${ARCH}/modules_load || die "Could not read ${GK_SHARE}/${ARCH}/modules_load"

# Merge modules_load from config
for group_modules in ${!AMODULES_*}; do
	group="$(echo $group_modules | cut -d_ -f2)"
	eval cmodules="\$$group_modules"
	eval MODULES_${group}=\"\${MODULES_${group}} ${cmodules}\"
	print_info 1 "<config> Merged AMODULES_${group}:'${cmodules}' into MODULES_${group}"
done

setup_cache_dir
dump_debugcache

# Check /boot is mounted
if isTrue ${CMD_NOINSTALL}
then
	isTrue ${MOUNTBOOT} && print_info 2 'Skipping automatic mount of boot'
else
	if ! egrep -q ' /boot ' /proc/mounts
	then
		if egrep -q '^[^#].+	/boot	' /etc/fstab
		then
			if isTrue ${MOUNTBOOT}
			then
				if ! mount /boot
				then
					print_warning 1 "${BOLD}WARNING${NORMAL}: Failed to mount /boot!"
					echo
				else
					print_info 1 'mount: /boot mounted successfully!'
				fi
			else
				print_warning 1 "${BOLD}WARNING${NORMAL}: No mounted /boot partition detected!"
				print_warning 1 '         Run ``mount /boot`` to mount it!'
				echo
			fi
		fi
	elif isBootRO
	then
		if isTrue ${MOUNTBOOT}
		then
			if ! mount -o remount,rw /boot
			then
				print_warning 1 "${BOLD}WARNING${NORMAL}: Failed to remount /boot RW!"
				echo
			else
				print_info 1 "mount: /boot remounted read/write successfully!"
				BOOTRW=1
			fi
		fi
	fi
fi

KERNCACHE_IS_VALID=0
if [ "${KERNCACHE}" != "" ] 
then
    gen_kerncache_is_valid
fi

if [ ${BUILD_KERNEL} -eq 1 -a "${KERNCACHE_IS_VALID}" == "0" ]
then
	# Configure kernel
	config_kernel
	
	# Make deps
	compile_dep

	# Make prepare [2.6]
	if [ "${ARCH_HAVENOPREPARE}" = '' ]
	then
		[ "${VER}" -gt '2' ] || [ "${VER}" -eq '2' -a "${PAT}" -ge '6' ] && compile_generic prepare kernel
	fi
	
	# KV may have changed due to the configuration
	get_KV

	# Compile kernel; If using --genzimage, or building a mips kernel, skip compile
	# till after initrd/initramfs is done
	[ "${GENERATE_Z_IMAGE}" = '' -a "${MIPS_EMBEDDED_IMAGE}" = '' ] && compile_kernel

	# Compile modules
	if [ ${BUILD_MODULES} -eq 1 ]
	then
		compile_modules
	fi

	if [ ${SAVE_CONFIG} -eq 1 ]
	then
		print_info 1 "Copying config for successful build to /etc/kernels/kernel-config-${ARCH}-${KV}"
		[ ! -e '/etc/kernels' ] && mkdir -p /etc/kernels
		cp "${KERNEL_DIR}/.config" "/etc/kernels/kernel-config-${ARCH}-${KV}"
	fi
	if [ "${KERNCACHE}" != "" ]
	then
		if [ "${GENERATE_Z_IMAGE}" = '' -a "${MIPS_EMBEDDED_IMAGE}" = '' ]
		then
			gen_kerncache
		fi
	fi
fi

if ! isTrue "${CMD_NOINSTALL}"
then
	if [ "${KERNCACHE}" != "" -a "${KERNCACHE_IS_VALID}" != "0" ] 
	then
		gen_kerncache_extract_kernel
	fi
fi

if [ "${KERNCACHE}" != "" -a "${KERNCACHE_IS_VALID}" != "0" ] 
then
	gen_kerncache_extract_modules
	gen_kerncache_extract_config
fi

if [ "${BUILD_INITRD}" -eq '1' ]
then
	[ "${DISKLABEL}" -eq '1' ] && compile_e2fsprogs
	compile_udev 

	if [ "${BUSYBOX}" -eq '1' ]
	then
		# Compile Busybox
		compile_busybox
	fi
	    
	# Compile initramfs
	create_initramfs
else
	print_info 1 'initrd: Not building since only the kernel was requested...'
fi

# Pegasos fix
if [ "${GENERATE_Z_IMAGE}" != '' -o "${MIPS_EMBEDDED_IMAGE}" != '' ]
then
	# Compile kernel, intergrating the initrd into it for Pegasos & mips
	compile_kernel

	# We skipped the kernel build and kerncache generation
	# So do it here
	[ "${KERNCACHE}" != "" ] && gen_kerncache
fi

[ "${MINKERNPACKAGE}" != '' ] && gen_minkernpackage
[ "${MODULESPACKAGE}" != '' ] && gen_modulespackage

# Clean up...
[ -n "${CTEMP}" ] && rm -rf "${TEMP}"

if [ "${BUILD_KERNEL}" -eq '1' ]
then
	set_bootloader
	print_info 1 ''
	print_info 1 "Kernel compiled successfully!"
	print_info 1 ''
	print_info 1 'Required Kernel Parameters:'
	if [ "${BUILD_INITRD}" -eq '0' ]
	then
		print_info 1 '    root=/dev/$ROOT'
		print_info 1 '    [ And "vga=0x317 splash=verbose" if you use a framebuffer ]'
		print_info 1 ''
		print_info 1 '    Where $ROOT is the device node for your root partition as the'
		print_info 1 '    one specified in /etc/fstab'
	elif [ "${KERN_24}" != '1' -a  "${CMD_BOOTSPLASH}" != '1' ]
	then
		print_info 1 '    real_root=/dev/$ROOT'
		print_info 1 ''
		print_info 1 '    Where $ROOT is the device node for your root partition as the'
		print_info 1 '    one specified in /etc/fstab'
		print_info 1 ''
		print_info 1 "If you require Genkernel's hardware detection features; you MUST"
		print_info 1 'tell your bootloader to use the provided INITRAMFS file. Otherwise;'
		print_info 1 'substitute the root argument for the real_root argument if you are'
		print_info 1 'not planning to use the initrd...'
	else	
		print_info 1 '    root=/dev/ram0 real_root=/dev/$ROOT init=/linuxrc'
		[ "${INITRD_SIZE}" -ge 4096 ] && print_info 1 "    ramdisk_size=${INITRD_SIZE}"
		print_info 1 ''
		print_info 1 '    Where $ROOT is the device node for your root partition as the'
		print_info 1 '    one specified in /etc/fstab'
		print_info 1 ''
		print_info 1 "If you require Genkernel's hardware detection features; you MUST"
		print_info 1 'tell your bootloader to use the provided INITRD file. Otherwise;'
		print_info 1 'substitute the root argument for the real_root argument if you are'
		print_info 1 'not planning to use the initrd...'
	fi
fi

if [ "${CMD_NOINSTALL}" != '1' -a "${SYMLINK}" = '1' ]
then 
    echo
    print_info 1 'Creating symlinks'   
    print_info 1 '	    creating kernel name symlink!'
    if [ -e /boot/kernel-${KNAME}-${ARCH}-${KV} ]
    then
	/bin/rm /boot/kernel
        ln -s /boot/kernel-${KNAME}-${ARCH}-${KV} /boot/kernel
        ret=$?
        [ ${ret} = '1' ] && print_error 1 'kernel link failed'
    fi

    if [ "${KERN_24}" != '1' -a  "${CMD_BOOTSPLASH}" != '1' ]
    then
	print_info 1 '	    creating initramfs name symlink!'
	if [ -e /boot/initramfs-${KNAME}-${ARCH}-${KV} ]
	then
	    /bin/rm /boot/initramfs
	    ln -s /boot/initramfs-${KNAME}-${ARCH}-${KV} /boot/initramfs
	    ret=$?
	    [ ${ret} = '1' ] && print_error 1 'initramfs link failed'
	fi
    else
	print_info 1 '	    creating initrd name symlink!'
	if [ -e /boot/initrd-${KNAME}-${ARCH}-${KV} ]
	then
	    /bin/rm /boot/initrd
	    ln -s /boot/initrd-${KNAME}-${ARCH}-${KV} /boot/initrd
	    ret=$?
	    [ ${ret} = '1' ] && print_error 1 'initrd link failed'
	fi
    fi
fi


[ "${BOOTRW}" != '' ] && mount -o remount,ro /boot

## >> FIXME: this needs to be displayed only if the kernel compile fails
print_info 1 'Do NOT report kernel bugs as genkernel bugs unless your bug'
print_info 1 'is about the default genkernel configuration...'
print_info 1 ''
print_info 1 'Make sure you have the latest genkernel before reporting bugs.'
## <<

# Final Cleanup
cleanup
